# Alternative Makefile using clang for systems without x86_64-elf-gcc
# This allows testing on macOS/Linux with native clang

# Compiler and assembler
CC = clang
AS = as
LD = ld

# Compiler flags for cross-compilation
CFLAGS = -target x86_64-unknown-none-elf -ffreestanding -fno-builtin -fno-stack-protector \
         -mno-red-zone -mcmodel=kernel -c -m64 -O2 -Wall -Wextra -I./include

# Assembler flags
ASFLAGS = 

# Linker flags
LDFLAGS = -nostdlib -T linker.ld -z max-page-size=0x1000

# Source files
SRC = src/kernel.c src/terminal.c src/keyboard.c src/ports.c src/timer.c \
      src/panic.c src/kmalloc.c src/process.c src/scheduler.c src/exceptions.c \
      src/syscall.c src/tss.c src/usermode.c src/pmm.c src/vmm.c src/elf.c

# Detect OS and use appropriate assembly files
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Darwin)
    ASM_SRC = src/asm_functions_macos.s src/boot_macos.s src/context_switch.s
    ASFLAGS = -arch x86_64
else
    ASM_SRC = src/asm_functions.s src/boot.s src/context_switch.s
    ASFLAGS =
endif

# Object files
OBJ = $(SRC:.c=.o) $(ASM_SRC:.s=.o)

# Output file
OUTPUT = kernel.bin
ISO = simpleos.iso

# Default target
all: $(ISO)

# Link object files to create the kernel binary
$(OUTPUT): $(OBJ)
	$(LD) $(LDFLAGS) -o $@ $^

# Compile C files
%.o: %.c
	$(CC) $(CFLAGS) $< -o $@

# Assemble assembly files
%.o: %.s
	$(AS) $(ASFLAGS) $< -o $@

# Create bootable ISO
$(ISO): $(OUTPUT)
	mkdir -p iso/boot/grub
	cp $(OUTPUT) iso/boot/
	cp boot/grub/grub.cfg iso/boot/grub/
	grub-mkrescue -o $(ISO) iso/ 2>/dev/null || \
		(echo "grub-mkrescue not found. Install with: brew install xorriso" && exit 1)
	rm -rf iso/

# Run in QEMU
run: $(ISO)
	qemu-system-x86_64 -cdrom $(ISO) -m 512M || \
		(echo "QEMU not found. Install with: brew install qemu" && exit 1)

# Debug in QEMU
debug: $(ISO)
	qemu-system-x86_64 -cdrom $(ISO) -m 512M -s -S

# Clean up built files
clean:
	rm -f $(OBJ) $(OUTPUT) $(ISO)
	rm -rf iso/

# Phony targets
.PHONY: all clean run debug